<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="REACT 面试题, 个人博客">
    <meta name="description" content="REACT 常见问题整理">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>REACT 面试题 | 个人博客</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    
        <link rel="stylesheet" type="text/css" href="/css/reward.css">
    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="个人博客" type="application/atom+xml">
</head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">个人博客</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">个人博客</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/xinghan-666" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/xinghan-666" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/12.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">REACT 面试题</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/REACT/">
                                <span class="chip bg-color">REACT</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-07-22
                </div>
                

                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    9.9k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    36 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.min.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="REACT-面试题"><a href="#REACT-面试题" class="headerlink" title="REACT 面试题"></a>REACT 面试题</h1><h2 id="1-如何创建-React-项目20qz-pylcc"><a href="#1-如何创建-React-项目20qz-pylcc" class="headerlink" title="1. 如何创建 React 项目20qz-pylcc"></a>1. 如何创建 React 项目<font color="white">20qz-pylcc</font></h2><pre class="line-numbers language-none"><code class="language-none">npm install create-react-app -g
create-react-app ./react-basic
cd react-basic
npm start

npm init react-app ./react-basic<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="2-如何理解-JSX"><a href="#2-如何理解-JSX" class="headerlink" title="2. 如何理解 JSX"></a>2. 如何理解 JSX</h2><pre class="line-numbers language-none"><code class="language-none">JSX 是 Facebook 创建的 JavaScript 语法扩展,React 中使用 JSX 来构建用户界面.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="3-在使用-JSX-时有哪些注意事项"><a href="#3-在使用-JSX-时有哪些注意事项" class="headerlink" title="3. 在使用 JSX 时有哪些注意事项"></a>3. 在使用 JSX 时有哪些注意事项</h2><pre class="line-numbers language-none"><code class="language-none">1. JSX 必须有根元素 &lt;&gt;&lt;/&gt;
2. 单标记必须闭合 &lt;img src="" /&gt;
3. 在 JSX 的外部可以加上小括号用于美化其对其方式
4. 只有表达式才可以嵌入到 JSX 中, 非表达式不可以 if else for switch
5. 属性名称遵循驼峰式命名法
6. Null undefined true false 可以被渲染 但是渲染的结果是空
7. JSX 中不能直接渲染对象
8. 使用 className 替换 class、使用 htmlFor 替换 for<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="4-如何将对象类型的数据直接嵌入-JSX-中"><a href="#4-如何将对象类型的数据直接嵌入-JSX-中" class="headerlink" title="4. 如何将对象类型的数据直接嵌入 JSX 中"></a>4. 如何将对象类型的数据直接嵌入 JSX 中</h2><pre class="line-numbers language-none"><code class="language-none">要将对象转换为对象的字符串格式才可以。JSON.stringify(obj)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="5-什么是条件渲染-在-React-中有哪些手段可以实现条件渲染。"><a href="#5-什么是条件渲染-在-React-中有哪些手段可以实现条件渲染。" class="headerlink" title="5. 什么是条件渲染, 在 React 中有哪些手段可以实现条件渲染。"></a>5. 什么是条件渲染, 在 React 中有哪些手段可以实现条件渲染。</h2><pre class="line-numbers language-none"><code class="language-none">根据条件决定渲染什么内容
if 三元运算 逻辑运算<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="6-如何实现列表渲染"><a href="#6-如何实现列表渲染" class="headerlink" title="6. 如何实现列表渲染"></a>6. 如何实现列表渲染</h2><pre class="line-numbers language-none"><code class="language-none">1. 先通过 map 方法将纯数据数组转换为 JSX 数组
2. 将 JSX 数组放入插入表达式中让其自动展开<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h2 id="7-在-React-中如何使用本地图片"><a href="#7-在-React-中如何使用本地图片" class="headerlink" title="7. 在 React 中如何使用本地图片"></a>7. 在 React 中如何使用本地图片</h2><pre class="line-numbers language-none"><code class="language-none">import img from "some/path";
const img = require("some/path");

&lt;img src={img} /&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="8-简要说明如何为元素绑定事件"><a href="#8-简要说明如何为元素绑定事件" class="headerlink" title="8. 简要说明如何为元素绑定事件"></a>8. 简要说明如何为元素绑定事件</h2><pre class="line-numbers language-none"><code class="language-none">事件名称采用驼峰式命名法, 将事件名称直接作为属性添加到元素的身上
事件名称对应的值,就是事件处理函数本身

&lt;element onClick={() =&gt; {}}&gt;&lt;/element&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="9-什么是组件、组件为开发者带来了哪些好处"><a href="#9-什么是组件、组件为开发者带来了哪些好处" class="headerlink" title="9. 什么是组件、组件为开发者带来了哪些好处"></a>9. 什么是组件、组件为开发者带来了哪些好处</h2><pre class="line-numbers language-none"><code class="language-none">组件就是可以被组合的零部件, React 采用组件化的方式构建用户界面
就是将一个完整的页面拆分成一个一个小的部分再组合
一个组件就是页面中的一小块区域, 要包含 html 结构、css 样式、javascript 逻辑
React 中有两种组件：函数式组件和class组件。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="10-如何为组件添加组件级样式"><a href="#10-如何为组件添加组件级样式" class="headerlink" title="10. 如何为组件添加组件级样式"></a>10. 如何为组件添加组件级样式</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">1. 创建样式表文件, 文件名称必须以 .module.css 结尾, 名称前面一般约定写组件名称, 比如 App.module.css
2. 在组件中通过 import styles from "./App.module.css" 的方式导入样式表
3. 在组件中通过 className 使用样式表中的样式
		&lt;element className={styles.样式表中的类名}/&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="11-类组件如何声明组件状态、如何获取组件状态、如何修改组件状态"><a href="#11-类组件如何声明组件状态、如何获取组件状态、如何修改组件状态" class="headerlink" title="11. 类组件如何声明组件状态、如何获取组件状态、如何修改组件状态"></a>11. 类组件如何声明组件状态、如何获取组件状态、如何修改组件状态</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">将组件状态存储到 state 属性中, state 属性的值是对象类型, 对象中的属性就是状态
在 render 方法中: this.state.状态
this.setState()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="12-类组件中的-constructor-方法、render-方法中的-this-指向谁"><a href="#12-类组件中的-constructor-方法、render-方法中的-this-指向谁" class="headerlink" title="12. 类组件中的 constructor 方法、render 方法中的 this 指向谁?"></a>12. 类组件中的 constructor 方法、render 方法中的 this 指向谁?</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">当前类的实例对象<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</code></pre>
<h2 id="13-如何使事件处理函数中的-this-指向当前组件的实例对象"><a href="#13-如何使事件处理函数中的-this-指向当前组件的实例对象" class="headerlink" title="13. 如何使事件处理函数中的 this 指向当前组件的实例对象"></a>13. 如何使事件处理函数中的 this 指向当前组件的实例对象</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">1. 将事件处理函数更改为箭头函数
2. 使用 bind 更改事件处理函数中的this
3. &lt;element onClick={() =&gt; this.clickHandler()} /&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="14-在类组件中如何获取-DOM-对象"><a href="#14-在类组件中如何获取-DOM-对象" class="headerlink" title="14. 在类组件中如何获取 DOM 对象"></a>14. 在类组件中如何获取 DOM 对象</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">import { createRef } from "react";

class App extends React.Component {
	divRef = createRef();
	render() {
		return &lt;div ref={divRef} onClick={() =&gt; console.log(divRef.current)}&gt;&lt;/div&gt;
	}
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="15-什么是受控表单、如何实现受控表单"><a href="#15-什么是受控表单、如何实现受控表单" class="headerlink" title="15. 什么是受控表单、如何实现受控表单"></a>15. 什么是受控表单、如何实现受控表单</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">表单的值由组件状态进行控制, 用户在表单中实时输入的时候, 我们要将用户输入的内容同步到组件状态之中, 开发者要想获取表单值, 只需要从组件状态中进行获取即可.

	class App extends React.Component {
		state = {
			text: ""
		}
		render() {
			return &lt;input type="text" value={this.state.text} onChange={(event) =&gt; this.setState({text: event.target.value})}/&gt;
		}
	}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="16-什么是组件通讯"><a href="#16-什么是组件通讯" class="headerlink" title="16. 什么是组件通讯"></a>16. 什么是组件通讯</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">数据能够在不同的组件之间进行流动。
父组件能够将自己的状态传递到子组件, 子组件可以修改父组件中定义的状态<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="17-如果向组件内部传递数据、如何在组件内部获取数据"><a href="#17-如果向组件内部传递数据、如何在组件内部获取数据" class="headerlink" title="17. 如果向组件内部传递数据、如何在组件内部获取数据"></a>17. 如果向组件内部传递数据、如何在组件内部获取数据</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">通过组件属性的方式(props)

&lt;App name="张三"/&gt;

class App extends React.Component {
	render() {
		this.props.name
	}
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="18-什么是单向数据流动"><a href="#18-什么是单向数据流动" class="headerlink" title="18. 什么是单向数据流动"></a>18. 什么是单向数据流动</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">数据在组件之间进行流动的时候, 方向只能是从上到下, 也就是说, 只能上层组件中的数据传递到下层组件
使数据流动变得简单, 程序更加好维护.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="19-props-为什么是只读的"><a href="#19-props-为什么是只读的" class="headerlink" title="19. props 为什么是只读的."></a>19. props 为什么是只读的.</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">为了实现单向实现数据流动, 如果 props 不是只读的, 是可以修改的, 那么单向数据流动将无法实现.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</code></pre>
<h2 id="20-在子组件中如何更新父组件中的状态"><a href="#20-在子组件中如何更新父组件中的状态" class="headerlink" title="20. 在子组件中如何更新父组件中的状态"></a>20. 在子组件中如何更新父组件中的状态</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">父组件定义修改状态的方法, 父组件将修改状态的方式传递到子组件, 子组件通过父组件传递下来的方法进行状态的修改。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</code></pre>
<h2 id="21-如何实现兄弟组件通讯"><a href="#21-如何实现兄弟组件通讯" class="headerlink" title="21. 如何实现兄弟组件通讯"></a>21. 如何实现兄弟组件通讯</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">利用状态提升思想, 将兄弟组件之间需要共享的状态提供至它们之间公共的父级中, 然后通过 props 的方式再将状态分别传递到兄弟组件中.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</code></pre>
<h2 id="22-如何实现跨级组件通讯20qz-pylcc"><a href="#22-如何实现跨级组件通讯20qz-pylcc" class="headerlink" title="22. 如何实现跨级组件通讯20qz-pylcc"></a>22. 如何实现跨级组件通讯<font color="white">20qz-pylcc</font></h2><pre><code><pre class="line-numbers language-none"><code class="language-none">利用上下文对象实现.

import { createContext } from "react";

// Provider 用来保存状态并提供状态
// Consumer 用来获取状态
const { Provider, Consumer } = createContext();

&lt;Provider value={{name: "张三"}}&gt;
	&lt;App /&gt;
&lt;/Provider&gt;

&lt;Consumer&gt;
	{ (value) =&gt; &lt;div&gt;{value.name}&lt;/div&gt; }
&lt;/Consumer&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="23-组件属性校验的意义是什么"><a href="#23-组件属性校验的意义是什么" class="headerlink" title="23. 组件属性校验的意义是什么"></a>23. 组件属性校验的意义是什么</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">1. 防止组件的调用者传递错误的属性值类型, 导致组件内部的代码执行出错
2. 当组件的调用者传递了错误的属性值时, 给组件的调用者更加精准的错误提示

npm install prop-types

import PropTypes from "prop-types";

class App extends React.Component {
	static propTypes = {
		colors: PropTypes.array.isRequired
	}
}
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="24-什么是组件属性的默认值"><a href="#24-什么是组件属性的默认值" class="headerlink" title="24. 什么是组件属性的默认值"></a>24. 什么是组件属性的默认值</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">我们在定义组件的时候, 可以为即将接收的外部数据设置默认值, 组件的调用者在传值的情况下组件使用调用者传递的值, 没传就是用默认值, 这样可以防止组件代码执行出错.

	class App extends React.Component {
		static defaultProps = {};
	}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="25-什么是组件的生命周期"><a href="#25-什么是组件的生命周期" class="headerlink" title="25. 什么是组件的生命周期"></a>25. 什么是组件的生命周期</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">从组件创建到销毁, 它经历的整个过程被称之为组件的生命周期.
开发者通过组件生命周期函数将业务逻辑插入到组件运行的各个阶段.
所谓生命周期函数就是 React 提供的一些固定名字的函数, 在组件运行的各个阶段被自动调用.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="26-React-类组件中组件生命周期函数有几大阶段-分别对应哪些常见的生命周期函数"><a href="#26-React-类组件中组件生命周期函数有几大阶段-分别对应哪些常见的生命周期函数" class="headerlink" title="26. React 类组件中组件生命周期函数有几大阶段, 分别对应哪些常见的生命周期函数"></a>26. React 类组件中组件生命周期函数有几大阶段, 分别对应哪些常见的生命周期函数</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">1. 挂载阶段

	创建组件、渲染组件视图

	constructor render componentDidMount

	constructor: 做一些初始化的工作, 比如更改组件中的函数的this 指向、初始化状态对象、创建引用对象、创建业务逻辑需要的公共属性

	render: 渲染视图、不能直接调用 setState 更新状态

	componentDidMount: 操作DOM、发送网络请求、更新组件状态

2. 更新阶段

	1. 什么情况下会触发组件更新

		1. 组件状态发生变化
		2. 父组件更新
		3. 强制更新 forceUpdate

	2. render componentDidUpdate

		componentDidUpdate: 操作DOM、发送网络请求、有条件的更新组件状态

3. 卸载阶段

	componentWillUnMount

	清理操作、清除定时器、清除事件、清除订阅、清除全局状态<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="27-页面初始渲染时要请求的数据要写在哪个生命周期函数中"><a href="#27-页面初始渲染时要请求的数据要写在哪个生命周期函数中" class="headerlink" title="27. 页面初始渲染时要请求的数据要写在哪个生命周期函数中"></a>27. 页面初始渲染时要请求的数据要写在哪个生命周期函数中</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">componentDidMount<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</code></pre>
<h2 id="28-组件卸载之前需要干些什么事情"><a href="#28-组件卸载之前需要干些什么事情" class="headerlink" title="28. 组件卸载之前需要干些什么事情"></a>28. 组件卸载之前需要干些什么事情</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">清理操作、清除定时器、清除事件、清除订阅、清除全局状态<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</code></pre>
<h2 id="29-在调用-setState-方法时传递对象作为参数和传递函数作为参数主要的区别在哪"><a href="#29-在调用-setState-方法时传递对象作为参数和传递函数作为参数主要的区别在哪" class="headerlink" title="29. 在调用 setState 方法时传递对象作为参数和传递函数作为参数主要的区别在哪"></a>29. 在调用 setState 方法时传递对象作为参数和传递函数作为参数主要的区别在哪</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">
区别主要体现在同时多次调用 setState 方法时, 传递对象在做状态合并时, 它是覆盖式合并, 传递函数时, 它是累计性合并.

this.setState({count: 1})
this.setState({count: 1})

this.setState((state) =&gt; ({count: state.count + 1}))
this.setState((state) =&gt; ({count: state.count + 1}))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="30-为什么在调用-setState-方法之后不能立即获取到更新之后的状态值"><a href="#30-为什么在调用-setState-方法之后不能立即获取到更新之后的状态值" class="headerlink" title="30. 为什么在调用 setState 方法之后不能立即获取到更新之后的状态值"></a>30. 为什么在调用 setState 方法之后不能立即获取到更新之后的状态值</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">在 React 中，当调用 setState 方法更新组件的状态时，React 并不会立即更新组件的状态，而是会将状态更新请求放入更新队列中，以便在适当的时候进行更新。这是因为 React 会将多个 setState 方法调用进行合并，以提高性能和优化更新。

因此，如果在调用 setState 后立即尝试访问状态值，可能会得到之前的状态值，因为此时更新队列尚未被处理。如果需要在更新完成后访问更新后的状态值，可以使用 setState 的第二个参数，即回调函数。回调函数会在组件状态更新完成后被调用，可以在回调函数中访问更新后的状态值。

this.setState({count: this.state.count + 1}, () =&gt; {
  console.log(this.state.count); // 在回调函数中访问更新后的状态值
});<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="31-什么是浅比较"><a href="#31-什么是浅比较" class="headerlink" title="31. 什么是浅比较"></a>31. 什么是浅比较</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">在 React 中，当一个组件的状态或属性更新时，React 会进行一个称为“比较”的过程来确定是否需要重新渲染组件。浅比较是 React 中一种比较对象的方式，用于检查两个对象是否相等。

浅比较只会比较对象的引用，而不会比较对象的值。如果两个对象的引用不同，即使它们的值相同，浅比较也会认为它们是不相等的。如果两个对象的引用相同，即使它们的值已经发生了变化，浅比较仍然认为它们是相等的。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="32-PureComponent-类的作用是什么"><a href="#32-PureComponent-类的作用是什么" class="headerlink" title="32. PureComponent 类的作用是什么"></a>32. PureComponent 类的作用是什么</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">可以防止组件的无效渲染.
在组件即将更新之前, PureComponent 会拿着上一次更新组件时使用的 props 和 即将更新组件时使用的 prop 进行比较
如果比较结果是相同的, 阻止组件渲染, 因为即使重新渲染, 得到的最终结果也是一样的.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="33-shouldComponentUpdate-生命周期函数的作用是什么"><a href="#33-shouldComponentUpdate-生命周期函数的作用是什么" class="headerlink" title="33. shouldComponentUpdate 生命周期函数的作用是什么"></a>33. shouldComponentUpdate 生命周期函数的作用是什么</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">通过 shouldComponentUpdate 生命周期函数的返回值可以决定组件是否继续更新. true 继续更新 false 阻止更新.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</code></pre>
<h2 id="34-组件状态管理存在什么问题"><a href="#34-组件状态管理存在什么问题" class="headerlink" title="34. 组件状态管理存在什么问题"></a>34. 组件状态管理存在什么问题</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">当组件与组件之间要进行状态共享的时候, 状态需要在不同的组件之间通过 props 的方式进行传递, 传递过程非常复杂.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</code></pre>
<h2 id="35-和组件状态管理相比-全局状态管理有什么优势"><a href="#35-和组件状态管理相比-全局状态管理有什么优势" class="headerlink" title="35. 和组件状态管理相比, 全局状态管理有什么优势"></a>35. 和组件状态管理相比, 全局状态管理有什么优势</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">全局状态管理是指将状态存储到一个脱离于组件的地方进行管理, 所有组件都可以直接获取状态, 直接修改状态, 避免了组件状态管理中的 状态需要在不同的组件之间进行传递的复杂过程.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</code></pre>
<h2 id="36-简要描述-Redux-管理状态的模式"><a href="#36-简要描述-Redux-管理状态的模式" class="headerlink" title="36. 简要描述 Redux 管理状态的模式"></a>36. 简要描述 Redux 管理状态的模式</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">在 Redux 中通过 store 对象进行状态的管理, store 对象可以存储状态, 有提供了管理状态的方法.
通过 store.getState 获取状态, 通过 store.dispatch 修改状态, 通过 store.subscribe 订阅状态的变化.

在 Redux 中对状态进行的任何修改都需要通过 action 对象进行描述, action 对象中有 type 属性, 它就是具体的用来描述的属性
视图中要想修改状态, 必须调用 dispatch 方法接收 action 对象, 该命令会被 reducer 函数接收, 在 reducer 函数要对 action.type 进行匹配
根据 action 的类型对状态进行不同的处理, 处理完成之后要返回, 给 store 进行存储.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="37-在-Redux-中通过什么方法创建-store-对象-并描述该方法的使用方式"><a href="#37-在-Redux-中通过什么方法创建-store-对象-并描述该方法的使用方式" class="headerlink" title="37. 在 Redux 中通过什么方法创建 store 对象, 并描述该方法的使用方式"></a>37. 在 Redux 中通过什么方法创建 store 对象, 并描述该方法的使用方式</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">const store = createStore(reducer, initialState)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</code></pre>
<h2 id="38-描述-action-对象的作用是什么、什么是-action-creator、为什么会有-action-creator-这样的概念"><a href="#38-描述-action-对象的作用是什么、什么是-action-creator、为什么会有-action-creator-这样的概念" class="headerlink" title="38. 描述 action 对象的作用是什么、什么是 action creator、为什么会有 action creator 这样的概念"></a>38. 描述 action 对象的作用是什么、什么是 action creator、为什么会有 action creator 这样的概念</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">在 Redux 中, action 对象用于描述当前要对状态进行怎样的操作, 它就是一个命令, 通过 dispatch 进行发送.
action creator 就是一个用于返回 action 对象的函数
它存在的目的是消除相似 action 对象的重复定义

{ type: "increment", payload: 1 }
{ type: "increment", payload: 2 }
{ type: "increment", payload: 3 }

const increment = (payload) =&gt; ({type: "increment", payload})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="39-简要描述-reducer-函数的用法"><a href="#39-简要描述-reducer-函数的用法" class="headerlink" title="39. 简要描述 reducer 函数的用法"></a>39. 简要描述 reducer 函数的用法</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">reducer 就是一个函数, 在 Redux 中用于对状态进行更新, 是具体的写更新状态代码的地方.
reducer 函数接收两个参数, 第一个参数是要管理的状态对象, 第二个参数是 action 对象
在 reducer 函数内部, 我们通常通过编写 switch case 对 action 类型进行匹配, 根据不同的 action 类型, 对状态进行不同的更新.
在状态更新完成之后, 必须要返回新的状态, 如果没有匹配到 action type, 默认就返回当前状态.
在 reducer 中不能做任何和修改状态无关的事情, 比如发送 ajax 请求, 开启定时器等<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="40-在-redux-中使用什么方法获取状态仓库中存储的状态对象"><a href="#40-在-redux-中使用什么方法获取状态仓库中存储的状态对象" class="headerlink" title="40. 在 redux 中使用什么方法获取状态仓库中存储的状态对象"></a>40. 在 redux 中使用什么方法获取状态仓库中存储的状态对象</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">在 Redux 中获取状态仓库中存储的状态对象，可以使用 Redux 提供的 getState() 方法。getState() 方法是 Redux Store 对象中的一个函数，用于返回当前的状态树对象。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</code></pre>
<h2 id="41-在-redux-中使用什么方法分发-action-对象"><a href="#41-在-redux-中使用什么方法分发-action-对象" class="headerlink" title="41. 在 redux 中使用什么方法分发 action 对象"></a>41. 在 redux 中使用什么方法分发 action 对象</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">在 Redux 中分发 action 对象，可以使用 Redux 提供的 dispatch() 方法。dispatch() 方法是 Redux Store 对象中的一个函数，用于向 reducer 发送 action 对象，并触发 state 的更新。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</code></pre>
<h2 id="42-react-redux-这个库的作用是什么"><a href="#42-react-redux-这个库的作用是什么" class="headerlink" title="42. react-redux 这个库的作用是什么?"></a>42. react-redux 这个库的作用是什么?</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">解决 redux 状态更新组件不更新的问题<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</code></pre>
<h2 id="43-简要描述-react-redux-中提供的-connect-方法的作用及用法"><a href="#43-简要描述-react-redux-中提供的-connect-方法的作用及用法" class="headerlink" title="43. 简要描述 react-redux 中提供的 connect 方法的作用及用法"></a>43. 简要描述 react-redux 中提供的 connect 方法的作用及用法</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">react-redux 提供了 connect 方法让组件获取状态

connect 方法有两个参数都是函数, 第一个函数用于将 redux 状态映射到组件的 props 对象中
第二个函数用于将修改状态的逻辑映射到组件的 props 对象中
connect 方法在调用之后又返回一个函数, 通过调用该函数告诉 redux 状态及修改状态的逻辑要映射到哪一个组件中
connect 方法返回的方法在调用之后返回了一个被增强了的组件, 外部要渲染该组件

export default connect(mapStateToProps, mapDispatchToProps)(App)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="44-为什么要将-action-对象中的-type-属性值定义为常量-20qz-pylcc"><a href="#44-为什么要将-action-对象中的-type-属性值定义为常量-20qz-pylcc" class="headerlink" title="44. 为什么要将 action 对象中的 type 属性值定义为常量 20qz-pylcc"></a>44. 为什么要将 action 对象中的 type 属性值定义为常量 <font color="white">20qz-pylcc</font></h2><pre><code><pre class="line-numbers language-none"><code class="language-none">在 Redux 中，将 action 对象中的 type 属性值定义为常量，可以提高应用的可维护性和可重用性。

具体来说，将 action 类型定义为常量，可以避免由于手误或代码错误而导致的拼写错误，从而避免出现难以追踪的 bug。此外，常量还可以更好地传达代码中的含义，从而提高代码的可读性和可维护性。

另外，定义 action 类型为常量还可以增加代码的重用性。在 Redux 应用中，可能有多个 reducer 需要处理相同的 action 类型，如果将 action 类型定义为常量，可以将这些常量集中到一个文件中，然后在多个 reducer 中重复使用，从而减少重复的代码。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="45-reducer-函数为什么要被分解再组合20qz-pylcc"><a href="#45-reducer-函数为什么要被分解再组合20qz-pylcc" class="headerlink" title="45. reducer 函数为什么要被分解再组合20qz-pylcc"></a>45. reducer 函数为什么要被分解再组合<font color="white">20qz-pylcc</font></h2><pre><code><pre class="line-numbers language-none"><code class="language-none">在 Redux 应用中，reducer 函数被分解再组合可以提高应用的可维护性和可扩展性。

具体来说，将 reducer 函数分解成多个小的 reducer 函数，可以将不同部分的状态分开管理，从而使代码更加清晰和易于维护。
Redux 提供了 combineReducers() 函数，它可以将多个 reducer 函数合并成一个 reducer 函数，并生成一个新的状态树对象。这样，我们可以将不同部分的状态分开管理，并将它们组合成一个完整的状态树，从而使代码更加清晰、易于维护和可扩展。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="46-如何理解-redux-中间件"><a href="#46-如何理解-redux-中间件" class="headerlink" title="46. 如何理解 redux 中间件"></a>46. 如何理解 redux 中间件</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">redux 中间件允许开发者在修改状态的过程中加入一些中间环节, 在 reducer 函数中不能做的事情, 全部都要在中间件中去做
比如异步请求、定时器、控制台输出、DOM 操作、localStorage<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="47-redux-thunk-中间件的作用是什么-如何使用该中间件。"><a href="#47-redux-thunk-中间件的作用是什么-如何使用该中间件。" class="headerlink" title="47. redux-thunk 中间件的作用是什么, 如何使用该中间件。"></a>47. redux-thunk 中间件的作用是什么, 如何使用该中间件。</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">扩展了 dispatch 方法的功能, 使 dispatch 方法可以接收函数作为参数, 开发者可以将副作用代码写在该函数中, 比如异步请求,
其实就是让开发者在 redux 的工作流程中加入异步代码.

npm install redux-thunk

import thunk from "redux-thunk";

createStore(reducer, applyMiddleware(thunk));

dispatch(async (dispatch) =&gt; {
	// 异步操作
	dispatch();
})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="48-BrowserRouter-内部使用的是什么-API-实现的路由功能"><a href="#48-BrowserRouter-内部使用的是什么-API-实现的路由功能" class="headerlink" title="48. BrowserRouter 内部使用的是什么 API 实现的路由功能"></a>48. BrowserRouter 内部使用的是什么 API 实现的路由功能</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">在 React Router 库中，BrowserRouter 使用 HTML5 的 history API 实现了路由功能。

history API 是 HTML5 中引入的一组 API，用于在浏览器中操作浏览器的历史记录和地址栏。使用 history API，我们可以通过 JavaScript 修改 URL，同时还可以监听 URL 的变化，从而实现前端路由功能。

BrowserRouter 组件使用了 history API 中的 pushState() 和 replaceState() 方法，将 URL 中的路径与组件进行匹配，以确定要渲染的组件。当 URL 发生变化时，BrowserRouter 会通过 props 将新的 location 信息传递给子组件，从而触发重新渲染。
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="49-在-react-router-dom-路由库中使用什么组件配置路由规则-使用的是什么属性"><a href="#49-在-react-router-dom-路由库中使用什么组件配置路由规则-使用的是什么属性" class="headerlink" title="49. 在 react-router-dom 路由库中使用什么组件配置路由规则, 使用的是什么属性"></a>49. 在 react-router-dom 路由库中使用什么组件配置路由规则, 使用的是什么属性</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">&lt;Route path="/home" component={Home} /&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</code></pre>
<h2 id="50-使用哪些组件可以实现-a-链接跳转-它们之间有什么区别"><a href="#50-使用哪些组件可以实现-a-链接跳转-它们之间有什么区别" class="headerlink" title="50. 使用哪些组件可以实现 a 链接跳转? 它们之间有什么区别"></a>50. 使用哪些组件可以实现 a 链接跳转? 它们之间有什么区别</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">&lt;Link&gt;&lt;/Link&gt;
&lt;NavLink&gt;&lt;/NavLink&gt;

NavLink 链接被激活之后有高亮的类名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="51-使用哪些方法可以实现编程式导航-它们之间有什么区别"><a href="#51-使用哪些方法可以实现编程式导航-它们之间有什么区别" class="headerlink" title="51. 使用哪些方法可以实现编程式导航? 它们之间有什么区别"></a>51. 使用哪些方法可以实现编程式导航? 它们之间有什么区别</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">push      正常跳转, 记录会被添加到浏览器的历史记录中, 可以回退
replace   跳转, 但是跳转记录不会被添加到浏览器的历史记录中, 不可以回退<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="52-什么是查询参数？"><a href="#52-什么是查询参数？" class="headerlink" title="52. 什么是查询参数？"></a>52. 什么是查询参数？</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">查询参数是指 URL 中的一部分，通常用于向服务器传递额外的信息。查询参数以 "?" 符号开始，后面是一系列键值对，多个键值对之间使用 "&amp;" 符号分隔。
https://www.example.com/search?q=react&amp;lang=en<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="53-如何传递查询参数"><a href="#53-如何传递查询参数" class="headerlink" title="53. 如何传递查询参数"></a>53. 如何传递查询参数</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">&lt;Link to="/detail?aid=1"&gt;&lt;/Link&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</code></pre>
<h2 id="54-如何接收查询参数20qz-pylcc"><a href="#54-如何接收查询参数20qz-pylcc" class="headerlink" title="54. 如何接收查询参数20qz-pylcc"></a>54. 如何接收查询参数<font color="white">20qz-pylcc</font></h2><pre><code><pre class="line-numbers language-none"><code class="language-none">qs.parse(this.props.location.search, {ignoreQueryPrefix: true})<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</code></pre>
<h2 id="55-如何实现路径参数的路由传参"><a href="#55-如何实现路径参数的路由传参" class="headerlink" title="55. 如何实现路径参数的路由传参"></a>55. 如何实现路径参数的路由传参</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">1. 在路由规则中指定要进入到当前路由需要传递参数

		&lt;Route path="/detail/:id" /&gt;

2. 在链接中传递参数

		&lt;Link to="/detail/1"&gt;&lt;/Link&gt;

3. 接收参数

		match.params<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="56-Switch-组件的作用是什么"><a href="#56-Switch-组件的作用是什么" class="headerlink" title="56. Switch 组件的作用是什么"></a>56. Switch 组件的作用是什么</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">默认情况下, 路由规则是从上到下进行匹配的, 直到匹配完所有的路由规则, 匹配到哪些, 就渲染哪些路由规则对应的组件
Switch 组件可以指定在匹配到一个规则以后停止匹配<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="57-在路由规则中匹配请求路径时-它的匹配方式模式有哪些"><a href="#57-在路由规则中匹配请求路径时-它的匹配方式模式有哪些" class="headerlink" title="57. 在路由规则中匹配请求路径时, 它的匹配方式模式有哪些?"></a>57. 在路由规则中匹配请求路径时, 它的匹配方式模式有哪些?</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">精确匹配: 路由规则和请求路径完全吻合才能匹配成功, 要启用精确匹配, 需要 Route 组件的身上添加 exact 属性

模糊匹配(默认行为): 只要路由规则被请求路径所包裹即可匹配成功 /home =&gt; / 、 /home<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="58-在路由规则中如何定义-404-页面组件对应的路由规则"><a href="#58-在路由规则中如何定义-404-页面组件对应的路由规则" class="headerlink" title="58. 在路由规则中如何定义 404 页面组件对应的路由规则."></a>58. 在路由规则中如何定义 404 页面组件对应的路由规则.</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">路由规则从上到下依次进行匹配, 如果所有的路由规则都没有匹配成功, 就让它匹配最后一条

&lt;Route component={NotFound}/&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="59-如何在普通组件中获取路由相关的信息"><a href="#59-如何在普通组件中获取路由相关的信息" class="headerlink" title="59. 如何在普通组件中获取路由相关的信息."></a>59. 如何在普通组件中获取路由相关的信息.</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">withRouter<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</code></pre>
<h2 id="60-路由守卫组件的作用是什么"><a href="#60-路由守卫组件的作用是什么" class="headerlink" title="60. 路由守卫组件的作用是什么."></a>60. 路由守卫组件的作用是什么.</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">对路由组件进行的保护, 在进入组件之前, 判断你可以不以进入, 如果可以就让你进， 否则就不让你进.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</code></pre>
<h2 id="61-路由组件懒加载有什么好处-如何实现路由组件懒加载"><a href="#61-路由组件懒加载有什么好处-如何实现路由组件懒加载" class="headerlink" title="61. 路由组件懒加载有什么好处? 如何实现路由组件懒加载"></a>61. 路由组件懒加载有什么好处? 如何实现路由组件懒加载</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">提升首页加载速度.

lazy Suspense<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="62-如何在-JSX-中通过组件的方式进行页面跳转"><a href="#62-如何在-JSX-中通过组件的方式进行页面跳转" class="headerlink" title="62. 如何在 JSX 中通过组件的方式进行页面跳转."></a>62. 如何在 JSX 中通过组件的方式进行页面跳转.</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">&lt;Redirect to=""/&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</code></pre>
<h2 id="63-React-中的-render-的用途是什么？"><a href="#63-React-中的-render-的用途是什么？" class="headerlink" title="63. React 中的 render()的用途是什么？"></a>63. React 中的 render()的用途是什么？</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">在class组件中使用Render()，来返回在组件中显示的HTML。 它被用作读取props和state并将JSX代码返回到应用的根组件。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</code></pre>
<h2 id="64-什么是-Props？"><a href="#64-什么是-Props？" class="headerlink" title="64. 什么是 Props？"></a>64. 什么是 Props？</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">Props也被称作属性。它们将数据从一个组件传递到另一个组件（从父组件到子组件）。它们通常被用来呈现动态数据。
子组件永远不能将props发送到父组件，因为此流程是单向的（父到子）。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="65-如何区分-State-和-Props"><a href="#65-如何区分-State-和-Props" class="headerlink" title="65. 如何区分 State 和 Props"></a>65. 如何区分 State 和 Props</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">State和props是具有不同功能的JavaScript对象。

props用于将数据从父组件传输到子组件，而state是对本地数据的存储，仅对当前组件可用，不能与其他组件共享。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="66-useState-是什么？20qz-pylcc"><a href="#66-useState-是什么？20qz-pylcc" class="headerlink" title="66. useState 是什么？20qz-pylcc"></a>66. useState 是什么？<font color="white">20qz-pylcc</font></h2><pre><code><pre class="line-numbers language-none"><code class="language-none">useState Hook是一个可以在函数组件中使用状态变量的存储。你可以把初始状态传给这个函数，它将返回一个包含当前状态值（不一定是初始状态）的变量和另一个更新这个值的函数。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</code></pre>
<h2 id="67-useEffect-是什么？"><a href="#67-useEffect-是什么？" class="headerlink" title="67. useEffect 是什么？"></a>67. useEffect 是什么？</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">useEffect Hook允许你在组件中执行副作用，例如数据获取、直接更新DOM、使用setTimeout()之类的计时器等等。

这个hook接受两个参数：回调函数和依赖项，它们允许您控制何时执行副作用。

注意：第二个参数是可选的。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="68-useMemo-hook-的用途是什么？"><a href="#68-useMemo-hook-的用途是什么？" class="headerlink" title="68. useMemo() hook 的用途是什么？"></a>68. useMemo() hook 的用途是什么？</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">useMemo() hook在函数组件中使用来记忆昂贵的函数，以便它们仅在设定的输入更改时调用，而不是每次渲染都调用。
它类似于useCallback hook，用于优化React函数组件的渲染行为。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="69-React-的功能是什么？"><a href="#69-React-的功能是什么？" class="headerlink" title="69. React 的功能是什么？"></a>69. React 的功能是什么？</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">1.它使用虚拟DOM而不是真实DOM。
2.它使用服务器端渲染。
3.它遵循单向数据流或数据绑定。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="70-列出-React-的一些主要优点。"><a href="#70-列出-React-的一些主要优点。" class="headerlink" title="70. 列出 React 的一些主要优点。"></a>70. 列出 React 的一些主要优点。</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">它提高了应用程序的性能
它可以方便地在客户端和服务器端使用
由于有了JSX，代码的可读性提高了
React易于与其他框架（如Meteor，Angular等）集成
使用React，编写UI测试用例变得非常容易<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="71-对-Virtual-DOM-有什么了解？解释它的工作。"><a href="#71-对-Virtual-DOM-有什么了解？解释它的工作。" class="headerlink" title="71. 对 Virtual DOM 有什么了解？解释它的工作。"></a>71. 对 Virtual DOM 有什么了解？解释它的工作。</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">虚拟DOM是轻量级的JavaScript对象，其最初只是真实DOM的副本。 它是一个节点树，列出了元素，它们的属性和内容作为对象及其属性。React的render函数从React组件中创建一个节点树。然后，它会响应由用户或系统执行的各种操作引起的数据模型中的突变来更新此树。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</code></pre>
<h2 id="72-state-和-props-有何区别？"><a href="#72-state-和-props-有何区别？" class="headerlink" title="72. state 和 props 有何区别？"></a>72. state 和 props 有何区别？</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">定义位置不同：state 是在组件内部定义的，而 props 是从组件的父组件传递进来的。

可变性不同：state 是组件的内部状态，可以通过调用 setState() 方法来更新它的值，而 props 是从父组件传递进来的，通常是不可变的。

作用不同：state 用于存储组件的数据和状态，可以用来更新组件的视图。props 则用于从父组件向子组件传递数据和方法，用于子组件的渲染。

访问方式不同：在组件内部可以通过 this.state 来访问组件的 state 值，而在组件内部可以通过 this.props 来访问父组件传递给子组件的 props 值。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="73-什么是高阶组件？"><a href="#73-什么是高阶组件？" class="headerlink" title="73. 什么是高阶组件？"></a>73. 什么是高阶组件？</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">高阶组件是重用组件逻辑的高级方法。基本上，这是从React的组成性质衍生的模式。HOC是自定义组件，在其中包裹了另一个组件。他们可以接受任何动态提供的子组件，但不会修改或复制其输入组件中的任何行为。您可以说HOC是“纯”组件。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</code></pre>
<h2 id="74-Redux-遵循的三个原则是什么？"><a href="#74-Redux-遵循的三个原则是什么？" class="headerlink" title="74. Redux 遵循的三个原则是什么？"></a>74. Redux 遵循的三个原则是什么？</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">1.单一事实来源：整个应用程序的状态存储在单个存储中的对象/状态树中。单一状态树使跟踪随时间变化以及调试或检查应用程序变得更加容易。
2.状态是只读的：更改状态的唯一方法是触发操作。动作是描述更改的普通JS对象。就像状态是数据的最小表示一样，操作是数据更改的最小表示。
3.使用纯函数进行更改： 为了指定操作如何转换状态树，您需要纯函数。纯函数是那些返回值仅取决于其参数值的函数。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="75-对-React-refs-的理解？应用场景？"><a href="#75-对-React-refs-的理解？应用场景？" class="headerlink" title="75. 对 React refs 的理解？应用场景？"></a>75. 对 React refs 的理解？应用场景？</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">在 React 中，Refs 是一种允许我们访问 DOM 节点或者组件实例的方法。Refs 提供了一种方式，允许我们直接操作 DOM 节点或组件实例，而无需经过 React 的 Virtual DOM。

Refs 的主要作用是解决访问组件内部 DOM 节点的问题。在 React 中，由于组件的渲染是通过 Virtual DOM 实现的，因此在某些情况下需要直接访问组件内部的 DOM 节点，比如进行动画效果、获取输入框的值等等。

应用场景：

获取组件内部的 DOM 节点，比如获取表单元素的值、滚动条的位置等。

与第三方库或原生 API 集成，比如集成 Google 地图、视频播放器等，需要访问 DOM 节点或组件实例。

控制组件的生命周期，比如手动触发组件的某些生命周期函数。

处理焦点、选择等问题，比如实现自动聚焦、选中文本等。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="76-React-Router-的路由模式有哪些？"><a href="#76-React-Router-的路由模式有哪些？" class="headerlink" title="76. React-Router 的路由模式有哪些？"></a>76. React-Router 的路由模式有哪些？</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">BrowserRouter：基于 HTML5 的 History API，使用 HTML5 中的 pushState() 和 replaceState() 方法来实现路由跳转。

HashRouter：使用 URL 中的哈希值来实现路由跳转，这是一种旧的路由实现方式。

MemoryRouter：使用内存中的 history 实现路由跳转，不会改变 URL。

StaticRouter：用于服务器端渲染，通过将 URL 作为 props 传递给组件来实现路由跳转。

NativeRouter：用于 React Native 开发，提供了与 React Native 导航 API 一致的路由实现方式。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="77-React-中的-key-有什么作用？"><a href="#77-React-中的-key-有什么作用？" class="headerlink" title="77. React 中的 key 有什么作用？"></a>77. React 中的 key 有什么作用？</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">跟Vue一样，React 也存在 Diff算法，而元素key属性的作用是用于判断元素是新创建的还是被移动的元素，从而减少不必要的Diff

因此key的值需要为每一个元素赋予一个确定的标识<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="78-设置-key-的注意事项有哪些？"><a href="#78-设置-key-的注意事项有哪些？" class="headerlink" title="78. 设置 key 的注意事项有哪些？"></a>78. 设置 key 的注意事项有哪些？</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">key 应该是唯一的
key不要使用随机值（随机数在下一次 render 时，会重新生成一个数字）
避免使用 index 作为 key<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="79-什么是-HTTP"><a href="#79-什么是-HTTP" class="headerlink" title="79. 什么是 HTTP?"></a>79. 什么是 HTTP?</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">HTTP（Hypertext Transfer Protocol）是一种用于传输超文本的协议。它是 Web 的基础，用于客户端和服务器之间的通信，客户端通过 HTTP 请求获取 Web 页面或资源，服务器通过 HTTP 响应返回 Web 页面或资源。
HTTP 通常使用 TCP（Transmission Control Protocol）作为传输协议，在传输层之上实现了一个面向请求和响应的客户端和服务器之间的通信。HTTP 请求由客户端发起，包含请求方法、URL、HTTP 版本号、请求头和请求正文等信息；HTTP 响应由服务器返回，包含响应状态码、响应头和响应正文等信息。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="80-什么是-HTTPS？"><a href="#80-什么是-HTTPS？" class="headerlink" title="80. 什么是 HTTPS？"></a>80. 什么是 HTTPS？</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">HTTPS（Hypertext Transfer Protocol Secure）是基于 HTTP 协议的安全版本，它使用了 SSL/TLS 加密协议来保护数据传输的安全性和完整性。HTTPS 通过 SSL/TLS 协议对通信进行加密，可以防止数据在传输过程中被窃听和篡改。 HTTPS 的 URL 以 "https://" 开头，常用于传输敏感信息的 Web 应用，比如银行、电商等。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</code></pre>
<h2 id="81-HTTP-和-HTTPS-的区别"><a href="#81-HTTP-和-HTTPS-的区别" class="headerlink" title="81. HTTP 和 HTTPS 的区别?"></a>81. HTTP 和 HTTPS 的区别?</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">安全性：HTTP 不加密，数据传输容易被窃听和篡改；HTTPS 使用 SSL/TLS 加密协议，保证数据传输的安全性和完整性。

端口号：HTTP 默认使用端口号 80，HTTPS 默认使用端口号 443。

证书：HTTPS 需要使用 SSL/TLS 数字证书，用于验证服务器的身份和建立安全通道；而 HTTP 不需要证书。

性能：HTTPS 比 HTTP 的传输速度慢，因为 HTTPS 需要进行加密和解密操作，增加了服务器的负担和网络延迟。

SEO：HTTPS 可以提升网站的搜索引擎排名，因为谷歌等搜索引擎将 HTTPS 作为一个排名因素。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="82-为什么说-HTTPS-比-HTTP-安全"><a href="#82-为什么说-HTTPS-比-HTTP-安全" class="headerlink" title="82. 为什么说 HTTPS 比 HTTP 安全?"></a>82. 为什么说 HTTPS 比 HTTP 安全?</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">HTTPS 比 HTTP 更安全，主要是因为 HTTPS 在数据传输的过程中使用了 SSL/TLS 协议来加密和验证数据的完整性，从而保证了数据的安全性和完整性。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</code></pre>
<h2 id="83-HTTPS-是如何保证安全的？"><a href="#83-HTTPS-是如何保证安全的？" class="headerlink" title="83. HTTPS 是如何保证安全的？"></a>83. HTTPS 是如何保证安全的？</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">加密通信：HTTPS 使用 SSL/TLS 协议对通信过程进行加密，防止数据在传输过程中被窃听和篡改。SSL/TLS 协议通过使用公钥和私钥来建立安全通道，加密传输数据。

身份验证：HTTPS 使用 SSL/TLS 数字证书对服务器和客户端进行身份验证，防止中间人攻击。SSL/TLS 数字证书是由受信任的第三方机构颁发的，用于验证服务器的身份和建立安全通道。

数据完整性：HTTPS 使用消息摘要算法对传输的数据进行验证，保证数据的完整性，防止数据在传输过程中被篡改。消息摘要算法使用哈希函数将原始数据转换成固定长度的摘要值，然后将摘要值发送给接收方进行验证，如果验证失败，则说明数据已经被篡改。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="84-如何理解-UDP-和-TCP-区别"><a href="#84-如何理解-UDP-和-TCP-区别" class="headerlink" title="84. 如何理解 UDP 和 TCP? 区别?"></a>84. 如何理解 UDP 和 TCP? 区别?</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">UDP（User Datagram Protocol）和 TCP（Transmission Control Protocol）都是用于在网络中传输数据的协议
连接性：TCP 是一种面向连接的协议，而 UDP 是一种无连接的协议。TCP 在传输数据之前需要先建立连接，而 UDP 不需要建立连接。

可靠性：TCP 是一种可靠的协议，它通过确认和重传机制来保证数据传输的可靠性。UDP 是一种不可靠的协议，它不提供数据重传机制。

消息大小限制：TCP 没有消息大小的限制，而 UDP 的消息大小被限制在 65,507 个字节以内。

传输效率：由于 TCP 需要建立连接、确认和重传数据等机制，因此其传输效率相对较低。而 UDP 没有这些机制，因此其传输效率相对较高。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="85-DNS-协议-是什么？"><a href="#85-DNS-协议-是什么？" class="headerlink" title="85. DNS 协议 是什么？"></a>85. DNS 协议 是什么？</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">DNS（Domain Names System），域名系统，是互联网一项服务，是进行域名和与之相对应的 IP 地址进行转换的服务器<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</code></pre>
<h2 id="86-说说-DNS-完整的查询过程"><a href="#86-说说-DNS-完整的查询过程" class="headerlink" title="86. 说说 DNS 完整的查询过程?"></a>86. 说说 DNS 完整的查询过程?</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">首先搜索浏览器的 DNS 缓存，缓存中维护一张域名与 IP 地址的对应表

若没有命中，则继续搜索操作系统的 DNS 缓存

若仍然没有命中，则操作系统将域名发送至本地域名服务器，本地域名服务器采用递归查询自己的 DNS 缓存，查找成功则返回结果

若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行迭代查询

首先本地域名服务器向根域名服务器发起请求，根域名服务器返回顶级域名服务器的地址给本地服务器
本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求，获取权限域名服务器的地址
本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址
本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来

操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起

至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="87-说说地址栏输入-URL-敲下回车后发生了什么？"><a href="#87-说说地址栏输入-URL-敲下回车后发生了什么？" class="headerlink" title="87. 说说地址栏输入 URL 敲下回车后发生了什么？"></a>87. 说说地址栏输入 URL 敲下回车后发生了什么？</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">URL解析
DNS 查询
TCP 连接
HTTP 请求
响应请求
页面渲染<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="88-说说-HTTP1-0-x2F-1-1-x2F-2-0-的区别-20qz-pylcc"><a href="#88-说说-HTTP1-0-x2F-1-1-x2F-2-0-的区别-20qz-pylcc" class="headerlink" title="88. 说说 HTTP1.0/1.1/2.0 的区别?20qz-pylcc"></a>88. 说说 HTTP1.0/1.1/2.0 的区别?<font color="white">20qz-pylcc</font></h2><pre><code><pre class="line-numbers language-none"><code class="language-none">HTTP1.0：

浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接
HTTP1.1：

引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用
在同一个TCP连接里面，客户端可以同时发送多个请求
虽然允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的，服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理特别慢，后面就会有许多请求排队等着
新增了一些请求方法
新增了一些请求头和响应头
HTTP2.0：

采用二进制格式而非文本格式
完全多路复用，而非有序并阻塞的、只需一个连接即可实现并行
使用报头压缩，降低开销
服务器推送<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="89-说说-HTTP-常见的状态码有哪些，适用场景？"><a href="#89-说说-HTTP-常见的状态码有哪些，适用场景？" class="headerlink" title="89. 说说 HTTP 常见的状态码有哪些，适用场景？"></a>89. 说说 HTTP 常见的状态码有哪些，适用场景？</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">1 表示消息
2 表示成功
3 表示重定向
4 表示请求错误
5 表示服务器错误


100：客户端在发送POST数据给服务器前，征询服务器情况，看服务器是否处理POST的数据，如果不处理，客户端则不上传POST数据，如果处理，则POST上传数据。常用于POST大数据传输

206：一般用来做断点续传，或者是视频文件等大文件的加载

301：永久重定向会缓存。新域名替换旧域名，旧的域名不再使用时，用户访问旧域名时用301就重定向到新的域名

302：临时重定向不会缓存，常用 于未登陆的用户访问用户中心重定向到登录页面

304：协商缓存，告诉客户端有缓存，直接使用缓存中的数据，返回页面的只有头部信息，是没有内容部分

400：参数有误，请求无法被服务器识别

403：告诉客户端进制访问该站点或者资源，如在外网环境下，然后访问只有内网IP才能访问的时候则返回

404：服务器找不到资源时，或者服务器拒绝请求又不想说明理由时

503：服务器停机维护时，主动用503响应请求或 nginx 设置限速，超过限速，会返回503

504：网关超时<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="90-说一下-GET-和-POST-的区别？"><a href="#90-说一下-GET-和-POST-的区别？" class="headerlink" title="90. 说一下 GET 和 POST 的区别？"></a>90. 说一下 GET 和 POST 的区别？</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">GET在浏览器回退时是无害的，而POST会再次提交请求。
GET产生的URL地址可以被Bookmark，而POST不可以。
GET请求会被浏览器主动cache，而POST不会，除非手动设置。
GET请求只能进行url编码，而POST支持多种编码方式。
GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
GET请求在URL中传送的参数是有长度限制的，而POST没有。
对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
GET参数通过URL传递，POST放在Request body中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="91-常用的版本管理工具有哪些？"><a href="#91-常用的版本管理工具有哪些？" class="headerlink" title="91. 常用的版本管理工具有哪些？"></a>91. 常用的版本管理工具有哪些？</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">git   SVN<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</code></pre>
<h2 id="92-谈谈你对-git-的理解。"><a href="#92-谈谈你对-git-的理解。" class="headerlink" title="92. 谈谈你对 git 的理解。"></a>92. 谈谈你对 git 的理解。</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">git是一个分布式版本控制软件，最初目的是为更好地管理Linux内核开发而设计<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</code></pre>
<h2 id="93-git-常见的命令"><a href="#93-git-常见的命令" class="headerlink" title="93. git 常见的命令"></a>93. git 常见的命令</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">git add
git commit
git push
git pull
git clone
git checkout<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="94-说说-Git-中-fork-clone-branch-这三个概念，有什么区别"><a href="#94-说说-Git-中-fork-clone-branch-这三个概念，有什么区别" class="headerlink" title="94. 说说 Git 中 fork, clone,branch 这三个概念，有什么区别?"></a>94. 说说 Git 中 fork, clone,branch 这三个概念，有什么区别?</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">fork 只能对代码仓进行操作，且 fork 不属于 git 的命令，通常用于代码仓托管平台的一种“操作”
clone 是 git 的一种命令，它的作用是将文件从远程代码仓下载到本地，从而形成一个本地代码仓
branch 特征与 fork 很类似，fork 得到的是一个新的、自己的代码仓，而 branch 得到的是一个代码仓的一个新分支<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="95-说说对-git-pull-和-git-fetch-的理解？有什么区别？"><a href="#95-说说对-git-pull-和-git-fetch-的理解？有什么区别？" class="headerlink" title="95. 说说对 git pull 和 git fetch 的理解？有什么区别？"></a>95. 说说对 git pull 和 git fetch 的理解？有什么区别？</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">git fetch 命令用于从另一个存储库下载对象和引用
git pull 命令用于从另一个存储库或本地分支获取并集成(整合)

相同点：

在作用上他们的功能是大致相同的，都是起到了更新代码的作用
不同点：

git pull是相当于从远程仓库获取最新版本，然后再与本地分支merge，即git pull = git fetch + git merge
相比起来，git fetch 更安全也更符合实际要求，在 merge 前，我们可以查看更新情况，根据实际情况再决定是否合并<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="96-如何解决-git-冲突？"><a href="#96-如何解决-git-冲突？" class="headerlink" title="96. 如何解决 git 冲突？"></a>96. 如何解决 git 冲突？</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">当Git无法自动合并分支时，就必须首先解决冲突，解决冲突后，再提交，合并完成

解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="97-说说-git-发生冲突的场景？"><a href="#97-说说-git-发生冲突的场景？" class="headerlink" title="97. 说说 git 发生冲突的场景？"></a>97. 说说 git 发生冲突的场景？</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">一般情况下，出现分支的场景有如下：

多个分支代码合并到一个分支时
多个分支向同一个远端分支推送<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="98-git-reset-干什么的？"><a href="#98-git-reset-干什么的？" class="headerlink" title="98. git reset 干什么的？"></a>98. git reset 干什么的？</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">reset用于回退版本，可以遗弃不再使用的提交

执行遗弃时，需要根据影响的范围而指定不同的参数，可以指定是否复原索引或工作树内容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="99-git-revert-是干什么的？"><a href="#99-git-revert-是干什么的？" class="headerlink" title="99. git revert 是干什么的？"></a>99. git revert 是干什么的？</h2><pre><code><pre class="line-numbers language-none"><code class="language-none">跟git reset用法基本一致，git revert 撤销某次操作，此次操作之前和之后的 commit和history都会保留，并且把这次撤销，作为一次最新的提交<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</code></pre>
<h2 id="100-get-reset-和-git-revert-的区别20qz-pylcc"><a href="#100-get-reset-和-git-revert-的区别20qz-pylcc" class="headerlink" title="100. get reset 和 git revert 的区别20qz-pylcc"></a>100. get reset 和 git revert 的区别<font color="white">20qz-pylcc</font></h2><pre><code> <pre class="line-numbers language-none"><code class="language-none">git revert是用一次新的commit来回滚之前的commit，git reset是直接删除指定的commit
git reset 是把HEAD向后移动了一下，而git revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容
在回滚这一操作上看，效果差不多。但是在日后继续 merge 以前的老版本时有区别<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</code></pre>
<h2 id="101-当你开发到一半，现在要修改别的分支问题的时候，怎么处理？"><a href="#101-当你开发到一半，现在要修改别的分支问题的时候，怎么处理？" class="headerlink" title="101. 当你开发到一半，现在要修改别的分支问题的时候，怎么处理？"></a>101. 当你开发到一半，现在要修改别的分支问题的时候，怎么处理？</h2><pre><code> <pre class="line-numbers language-none"><code class="language-none">可以使用git stash缓存当前区域的代码

git stash：保存开发到一半的代码
git commit -m '修改问题'
git stash pop：将代码追加到最新的提交之后<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>

                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">编程中的小白</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://xinghan-666.github.io/2023/07/22/react-mian-shi-ti-zheng-li/">https://xinghan-666.github.io/2023/07/22/react-mian-shi-ti-zheng-li/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">编程中的小白</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/REACT/">
                                    <span class="chip bg-color">REACT</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="far fa-dot-circle"></i>&nbsp;本篇
            </div>
            <div class="card">
                <a href="/2023/07/22/react-mian-shi-ti-zheng-li/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/12.jpg" class="responsive-img" alt="REACT 面试题">
                        
                        <span class="card-title">REACT 面试题</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            REACT 常见问题整理
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-07-22
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            编程中的小白
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/REACT/">
                        <span class="chip bg-color">REACT</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2023/07/15/yi-cuo-dian-zheng-li/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/11.jpg" class="responsive-img" alt="易错点整理">
                        
                        <span class="card-title">易错点整理</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            易错点整理
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-07-15
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            编程中的小白
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E6%98%93%E9%94%99%E7%82%B9/">
                        <span class="chip bg-color">易错点</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="tencent"
                   type="playlist"
                   id="8907267250"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2023</span>
            
            <a href="/about" target="_blank">编程中的小白</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
                <span id="translate">|&nbsp;繁/简：</span><a id="translateLink" href="javascript:translatePage();">繁</a>
            
            <br>
            
                &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                        class="white-color">55.4k</span>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/xinghan-666" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:2936541941@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2936541941" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 2936541941" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
        <script type="text/javascript" src="/js/tw_cn.js"></script>
        <script type="text/javascript">
          var defaultEncoding = 2; //网站编写字体是否繁体，1-繁体，2-简体
          var translateDelay = 0; //延迟时间,若不在前, 要设定延迟翻译时间, 如100表示100ms,默认为0
          var cookieDomain = "https://xinghan-666.github.io"; //Cookie地址, 一定要设定, 通常为你的网址
          var msgToTraditionalChinese = "繁"; //此处可以更改为你想要显示的文字
          var msgToSimplifiedChinese = "简"; //同上，但两处均不建议更改
          var translateButtonId = "translateLink"; //默认互换id
          translateInitilization();
        </script>
    
    
    
        
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="/libs/others/sakura.js"><\/script>');
            }
        </script>
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
